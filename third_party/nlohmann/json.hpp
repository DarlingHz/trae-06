// This is a simplified version of nlohmann/json.hpp for demonstration purposes\n// In a real project, you should download the full version from https://github.com/nlohmann/json\n\n#pragma once\n\n#include <map>\n#include <vector>\n#include <string>\n#include <variant>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n\nnamespace nlohmann {\n\nclass json {\npublic:\n    using value_t = std::variant<\n        std::monostate,\n        bool,\n        int,\n        double,\n        std::string,\n        std::vector<json>,\n        std::map<std::string, json>\n    >;\n\n    json() : m_value(std::monostate{}) {}\n    json(bool b) : m_value(b) {}\n    json(int i) : m_value(i) {}\n    json(double d) : m_value(d) {}\n    json(const std::string& s) : m_value(s) {}\n    json(const char* s) : m_value(std::string(s)) {}\n    json(const std::vector<json>& v) : m_value(v) {}\n    json(const std::map<std::string, json>& m) : m_value(m) {}\n\n    // Accessors\n    bool is_null() const { return std::holds_alternative<std::monostate>(m_value); }\n    bool is_boolean() const { return std::holds_alternative<bool>(m_value); }\n    bool is_number() const { return is_number_integer() || is_number_float(); }\n    bool is_number_integer() const { return std::holds_alternative<int>(m_value); }\n    bool is_number_float() const { return std::holds_alternative<double>(m_value); }\n    bool is_string() const { return std::holds_alternative<std::string>(m_value); }\n    bool is_array() const { return std::holds_alternative<std::vector<json>>(m_value); }\n    bool is_object() const { return std::holds_alternative<std::map<std::string, json>>(m_value); }\n\n    // Conversions\n    bool get<bool>() const { return std::get<bool>(m_value); }\n    int get<int>() const { return std::get<int>(m_value); }\n    double get<double>() const { return std::get<double>(m_value); }\n    std::string get<std::string>() const { return std::get<std::string>(m_value); }\n    std::vector<json> get<std::vector<json>>() const { return std::get<std::vector<json>>(m_value); }\n    std::map<std::string, json> get<std::map<std::string, json>>() const { return std::get<std::map<std::string, json>>(m_value); }\n\n    // Array access\n    json& operator[](size_t index) {\n        auto& arr = std::get<std::vector<json>>(m_value);\n        if (index >= arr.size()) {\n            arr.resize(index + 1);\n        }\n        return arr[index];\n    }\n\n    const json& operator[](size_t index) const {\n        return std::get<std::vector<json>>(m_value)[index];\n    }\n\n    size_t size() const {\n        if (is_array()) {\n            return std::get<std::vector<json>>(m_value).size();\n        } else if (is_object()) {\n            return std::get<std::map<std::string, json>>(m_value).size();\n        }\n        return 0;\n    }\n\n    // Object access\n    json& operator[](const std::string& key) {\n        if (!is_object()) {\n            m_value = std::map<std::string, json>();\n        }\n        return std::get<std::map<std::string, json>>(m_value)[key];\n    }\n\n    const json& operator[](const std::string& key) const {\n        return std::get<std::map<std::string, json>>(m_value).at(key);\n    }\n\n    bool contains(const std::string& key) const {\n        if (!is_object()) {\n            return false;\n        }\n        const auto& obj = std::get<std::map<std::string, json>>(m_value);\n        return obj.find(key) != obj.end();\n    }\n\n    // Serialization (simplified)\n    std::string dump(int indent = -1) const {\n        std::ostringstream oss;\n        serialize(oss, indent, 0);\n        return oss.str();\n    }\n\nprivate:\n    void serialize(std::ostream& os, int indent, int current_indent) const {\n        if (is_null()) {\n            os << "null";\n        } else if (is_boolean()) {\n            os << (get<bool>() ? "true" : "false");\n        } else if (is_number_integer()) {\n            os << get<int>();\n        } else if (is_number_float()) {\n            os << get<double>();\n        } else if (is_string()) {\n            os << '"' << escape_string(get<std::string>()) << '"';\n        } else if (is_array()) {\n            const auto& arr = get<std::vector<json>>();\n            os << '[';\n            if (indent > 0 && !arr.empty()) {\n                os << '\n';\n                for (size_t i = 0; i < arr.size(); ++i) {\n                    os << std::string(current_indent + indent, ' ');\n                    arr[i].serialize(os, indent, current_indent + indent);\n                    if (i != arr.size() - 1) {\n                        os << ',';\n                    }\n                    os << '\n';\n                }\n                os << std::string(current_indent, ' ');\n            } else {\n                for (size_t i = 0; i < arr.size(); ++i) {\n                    arr[i].serialize(os, indent, current_indent + indent);\n                    if (i != arr.size() - 1) {\n                        os << ',';\n                    }\n                }\n            }\n            os << ']';\n        } else if (is_object()) {\n            const auto& obj = get<std::map<std::string, json>>();\n            os << '{';\n            if (indent > 0 && !obj.empty()) {\n                os << '\n';\n                size_t i = 0;\n                for (const auto& [key, value] : obj) {\n                    os << std::string(current_indent + indent, ' ');\n                    os << '"' << escape_string(key) << '"' << ": ";\n                    value.serialize(os, indent, current_indent + indent);\n                    if (i != obj.size() - 1) {\n                        os << ',';\n                    }\n                    os << '\n';\n                    ++i;\n                }\n                os << std::string(current_indent, ' ');\n            } else {\n                size_t i = 0;\n                for (const auto& [key, value] : obj) {\n                    os << '"' << escape_string(key) << '"' << ": ";\n                    value.serialize(os, indent, current_indent + indent);\n                    if (i != obj.size() - 1) {\n                        os << ',';\n                    }\n                    ++i;\n                }\n            }\n            os << '}';\n        }\n    }\n\n    std::string escape_string(const std::string& s) const {\n        std::string result;\n        for (char c : s) {\n            switch (c) {\n                case '"': result += '\\'; result += '"'; break;\n                case '\\': result += '\\'; result += '\\'; break;\n                case '\b': result += '\\'; result += 'b'; break;\n                case '\f': result += '\\'; result += 'f'; break;\n                case '\n': result += '\\'; result += 'n'; break;\n                case '\r': result += '\\'; result += 'r'; break;\n                case '\t': result += '\\'; result += 't'; break;\n                default: result += c; break;\n            }\n        }\n        return result;\n    }\n\n    value_t m_value;\n};\n\n// Parse from string (simplified)\ninline json parse(const std::string& s) {\n    size_t pos = 0;\n    auto skip_whitespace = [&]() {\n        while (pos < s.size() && std::isspace(static_cast<unsigned char>(s[pos]))) {\n            ++pos;\n        }\n    };\n\n    auto parse_null = [&]() -> json {\n        if (pos + 3 < s.size() && s.substr(pos, 4) == "null") {\n            pos += 4;\n            return json();\n        }\n        throw std::runtime_error("Invalid null value");\n    };\n\n    auto parse_boolean = [&]() -> json {\n        if (pos + 3 < s.size() && s.substr(pos, 4) == "true") {\n            pos += 4;\n            return json(true);\n        } else if (pos + 4 < s.size() && s.substr(pos, 5) == "false") {\n            pos += 5;\n            return json(false);\n        }\n        throw std::runtime_error("Invalid boolean value");\n    };\n\n    auto parse_number = [&]() -> json {\n        size_t start = pos;\n        if (s[pos] == '-' || s[pos] == '+') {\n            ++pos;\n        }\n        while (pos < s.size() && std::isdigit(static_cast<unsigned char>(s[pos]))) {\n            ++pos;\n        }\n        if (pos < s.size() && s[pos] == '.') {\n            ++pos;\n            while (pos < s.size() && std::isdigit(static_cast<unsigned char>(s[pos]))) {\n                ++pos;\n            }\n            return json(std::stod(s.substr(start, pos - start)));\n        }\n        return json(std::stoi(s.substr(start, pos - start)));\n    };\n\n    auto parse_string = [&]() -> json {\n        ++pos; // skip '"'\n        std::string result;\n        while (pos < s.size() && s[pos] != '"') {\n            if (s[pos] == '\\') {\n                ++pos;\n                if (pos >= s.size()) {\n                    throw std::runtime_error("Invalid escape sequence");\n                }\n                switch (s[pos]) {\n                    case '"': result += '"'; break;\n                    case '\\': result += '\\'; break;\n                    case 'b': result += '\b'; break;\n                    case 'f': result += '\f'; break;\n                    case 'n': result += '\n'; break;\n                    case 'r': result += '\r'; break;\n                    case 't': result += '\t'; break;\n                    default: result += s[pos]; break;\n                }\n            } else {\n                result += s[pos];\n            }\n            ++pos;\n        }\n        if (pos >= s.size() || s[pos] != '"') {\n            throw std::runtime_error("Invalid string value");\n        }\n        ++pos; // skip '"'\n        return json(result);\n    };\n\n    auto parse_array = [&]() -> json {\n        ++pos; // skip '['\n        std::vector<json> result;\n        skip_whitespace();\n        while (pos < s.size() && s[pos] != ']') {\n            result.push_back(parse(s));\n            skip_whitespace();\n            if (pos < s.size() && s[pos] == ',') {\n                ++pos;\n                skip_whitespace();\n            }\n        }\n        if (pos >= s.size() || s[pos] != ']') {\n            throw std::runtime_error("Invalid array value");\n        }\n        ++pos; // skip ']'\n        return json(result);\n    };\n\n    auto parse_object = [&]() -> json {\n        ++pos; // skip '{'\n        std::map<std::string, json> result;\n        skip_whitespace();\n        while (pos < s.size() && s[pos] != '}') {\n            json key_json = parse_string();\n            std::string key = key_json.get<std::string>();\n            skip_whitespace();\n            if (pos >= s.size() || s[pos] != ':') {\n                throw std::runtime_error("Invalid object key-value pair");\n            }\n            ++pos;\n            skip_whitespace();\n            json value = parse(s);\n            result[key] = value;\n            skip_whitespace();\n            if (pos < s.size() && s[pos] == ',') {\n                ++pos;\n                skip_whitespace();\n            }\n        }\n        if (pos >= s.size() || s[pos] != '}') {\n            throw std::runtime_error("Invalid object value");\n        }\n        ++pos; // skip '}'\n        return json(result);\n    };\n\n    skip_whitespace();\n    if (pos >= s.size()) {\n        return json();\n    }\n\n    char c = s[pos];\n    if (c == 'n') {\n        return parse_null();\n    } else if (c == 't' || c == 'f') {\n        return parse_boolean();\n    } else if (c == '-' || c == '+' || std::isdigit(static_cast<unsigned char>(c))) {\n        return parse_number();\n    } else if (c == '"') {\n        return parse_string();\n    } else if (c == '[') {\n        return parse_array();\n    } else if (c == '{') {\n        return parse_object();\n    }\n\n    throw std::runtime_error("Invalid JSON value");\n}